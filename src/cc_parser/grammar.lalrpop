use crate::cc_lexer;
use crate::vm::error::ErrorS;
use crate::cc_lexer::Token;
use crate::cc_parser::ast::Expression;
use crate::cc_parser::ast;
use hashbrown::HashMap;
use crate::cc_parser::ast::Fn;
use lalrpop_util::ParseError;

grammar<'err>(
    errors: &'err mut Vec<ParseError<usize, cc_lexer::Token, ErrorS>>
);

Spanned<T>: ast::Spanned<T> = <l:@L> <t:T> <r:@R> => (t, l..r);

pub Program: ast::Program = <statements:DeclS*> => ast::Program { <> };


DeclS = Spanned<Decl>;
Decl = {
    Stmt,
    DeclVar,
    DeclFun,
    DeclStruct,
}

DeclStruct: ast::Statement = {
  "struct" <name:identifier> <fields:StructFields> ";"  => 
    ast::Statement::Struct(ast::StatementStruct { <> })
}


StructFields: Vec<ast::Field> = {
   "{" <mut fields:(<SingleField>)*> "}" => {
      fields
    },
    () => Vec::new(),
}

SingleField: ast::Field = {
  <name:identifier> ":" <type_:Types> ","? =>
    ast::Field { <> }
}


DeclFun: ast::Statement = "fn" <function:Function> => ast::Statement::Fun(<>);

DeclVar: ast::Statement = "let" <name:identifier> <type_:(":" <Types>)?> <value:("=" <ExprS>)?> ";" =>
  ast::Statement::Var(ast::StatementVar {
        var: ast::Var { name, type_: type_},
        value,
      });


Stmt: ast::Statement = {
 StmtOpen,
 StmtClosed,
}


StmtOpen: ast::Statement = {
    "for" "(" <init:ForInit> <cond:ForCond> <update:ForIncr> ")" <body:Spanned<StmtOpen>> =>
        ast::Statement::For(Box::new(ast::StatementFor { <> })),

    "if" "(" <cond:ExprS> ")" <then_branch:Spanned<Stmt>> =>
        ast::Statement::If(Box::new(ast::StatementIf { <>, else_branch: None })),

    "if" "(" <cond:ExprS> ")" <then_branch:Spanned<StmtClosed>> "else" <else_branch:Spanned<StmtOpen>> =>
        ast::Statement::If(Box::new(ast::StatementIf { cond, then_branch, else_branch: Some(else_branch)})),

    "while" "(" <cond:ExprS> ")" <body:Spanned<StmtOpen>> =>
        ast::Statement::While(Box::new(ast::StatementWhile { <> })),


}

StmtClosed: ast::Statement = {
    "if" "(" <cond:ExprS> ")" <then_branch:Spanned<StmtClosed>> "else" <else_branch:Spanned<StmtClosed>> =>
        ast::Statement::If(Box::new(ast::StatementIf { cond, then_branch, else_branch: Some(else_branch) })),
    "while" "(" <cond:ExprS> ")" <body:Spanned<StmtClosed>> =>
        ast::Statement::While(Box::new(ast::StatementWhile { <> })),
    "for" "(" <init:ForInit> <cond:ForCond> <update:ForIncr> ")" <body:Spanned<StmtClosed>> =>
        ast::Statement::For(Box::new(ast::StatementFor { <> })),
    SmallStmt,
}

ForInit: Option<ast::StatementS> = {
    <Spanned<DeclVar>> => Some(<>),
    <Spanned<StmtExpr>> => Some(<>),
    ";" => None,
}

ForCond = <ExprS?> ";";

ForIncr = <ExprS?>;



SmallStmt = {
    StmtExpr,
    StmtBlock,
    StmtPrint,
    StmtPrintLn,
    StmtReturn,
}



StmtReturn: ast::Statement = "return" <value:ExprS?> ";" =>
  ast::Statement::Return(ast::StatementReturn { <> });

StmtPrintLn: ast::Statement = "println" <value:ExprS> ";" =>
  ast::Statement::PrintLn(ast::StatementPrintLn { <> });


StmtPrint: ast::Statement = "print" <value:ExprS> ";" =>
  ast::Statement::Print(ast::StatementPrint { <> });

StmtBlock: ast::Statement = StatementBlockIn => ast::Statement::Block(<>);

StatementBlockIn: ast::StatementBlock = "{" <statements:DeclS*> "}" =>
  ast::StatementBlock { <> };

StmtExpr: ast::Statement = <expr:ExprS> ";" =>
    ast::Statement::Expression(ast::StatementExpr { <> });


ExprS = Spanned<Expression>;

Expression = ExprAssign;

ExprAssign = {
    <name:identifier> "=" <value:ExprS> =>
        ast::Expression::Assign(Box::new(ast::ExprAssign {
            lhs: ast::Var { name, type_: None },
            rhs: value,
        })),
    ExprLogicOr,
}

ExprLogicOr = ExprInfix<ExprLogicOr, OpLogicOr, ExprLogicAnd>;
OpLogicOr: ast::OpInfix = "or" => ast::OpInfix::LogicOr;


ExprLogicAnd = ExprInfix<ExprLogicAnd, OpLogicAnd, ExprEquality>;
OpLogicAnd: ast::OpInfix = "and" => ast::OpInfix::LogicAnd;

ExprEquality = ExprInfix<ExprEquality, OpEquality, ExprComparison>;
OpEquality: ast::OpInfix = {
    "==" => ast::OpInfix::Equal,
    "!=" => ast::OpInfix::NotEqual,
}

ExprComparison = ExprInfix<ExprComparison, OpComparison, ExprTerm>;
OpComparison: ast::OpInfix = {
    ">" => ast::OpInfix::Greater,
    ">=" => ast::OpInfix::GreaterEqual,
    "<" => ast::OpInfix::Less,
    "<=" => ast::OpInfix::LessEqual,
}

ExprTerm = ExprInfix<ExprTerm, OpTerm, ExprFactor>;
OpTerm: ast::OpInfix = {
    "+" => ast::OpInfix::Add,
    "-" => ast::OpInfix::Sub,
}

ExprFactor = ExprInfix<ExprFactor, OpFactor, ExprPrefix>;
OpFactor: ast::OpInfix = {
    "*" => ast::OpInfix::Mul,
    "/" => ast::OpInfix::Div,
    "%" => ast::OpInfix::Modulo,
}


pub OpPrefix: ast::OpPrefix = {
  "-" => ast::OpPrefix::Negate,
  "!" => ast::OpPrefix::Not,  
}

ExprPrefix: ast::Expression = {
    <op:OpPrefix> <rt:Spanned<ExprPrefix>> =>
        ast::Expression::Prefix(Box::new(ast::ExprPrefix { <> })),
    ExprCall,
}

ExprCall: ast::Expression = {
    <callee:Spanned<ExprCall>> "(" <args:Args> ")" =>
      ast::Expression::Call(Box::new(ast::ExprCall { callee, args })),
//    <object:Spanned<ExprCall>> "." <name:identifier> =>
//        ast::Expr::Get(Box::new(ast::ExprGet { <> })),
      ExprPrimary
}


ExprPrimary: ast::Expression = {
    // Literals
    "nil" => ast::Expression::Literal(ast::ExprLiteral::Nil),
    "false" => ast::Expression::Literal(ast::ExprLiteral::Bool(false)),
    "true" => ast::Expression::Literal(ast::ExprLiteral::Bool(true)),
    string => ast::Expression::Literal(ast::ExprLiteral::String(<>)),
    number => ast::Expression::Literal(ast::ExprLiteral::Number(<>)),
    
    // Variables
    ExprVar,

    // Grouping
    "(" <Expression> ")",
}

Function: ast::StatementFun =
    <name:identifier>  "("  <params:Params> ")" <return_type:("->" <Types>)?>  <body:StatementBlockIn> =>
        ast::StatementFun { <> };


Params: HashMap<String, Option<ast::Type>> = {
    <first:Param> <mut params:("," <Param>)*> => {
        let mut param_map = HashMap::new();
        let (string_, type_) = first;
        param_map.insert(string_, type_);
        for (string_, type_) in params {
          param_map.insert(string_, type_);
        }
        param_map
    },
    () => HashMap::new(),
}

Param: (String, Option<ast::Type>) = {
  <string_:identifier> <type_:(":" <Types>)?> =>
    (string_,type_)
}

Args: Vec<ast::ExprS> = {
    <first:ExprS> <mut args:("," <ExprS>)*> => {
        args.insert(0, first);
        args
    },
    () => Vec::new(),
}

Types: ast::Type = {
  type_string => ast::Type::String,
  type_int => ast::Type::Int,
  "fn" => ast::Type::Fn(ast::Fn { return_type: Box::new(None) })
}


ExprVar: ast::Expression = <name:identifier> =>
  ast::Expression::Var(ast::ExprVar { var: ast::Var {name, type_: None} });



ExprInfix<Lhs, Op, Rhs>: ast::Expression =  {
  <lhs:Spanned<Lhs>> <op:Op> <rhs:Spanned<Rhs>> =>
  ast::Expression::Infix(Box::new(ast::ExprInfix { <> })),
  Rhs,
}

extern {
  type Location = usize;
  type Error = ErrorS;

  enum Token {
    // Keywords
    "let" => Token::Let,
    "and" => Token::And,
    "struct" => Token::Struct,
    "print" => Token::Print,
    "println" => Token::PrintLn,
    "if" => Token::If,
    "else" => Token::Else,
    "for" => Token::For,
    "while" => Token::While,
    "return" => Token::Return,
    "true" => Token::True,
    "false" => Token::False,
    "nil" => Token::Nil,
    "or" => Token::Or,
    "fn" => Token::Fn,

    // Literals
    string => Token::String(<String>),
    identifier => Token::Identifier(<String>),
    number => Token::Number(<f64>),

    type_string => Token::TypeString,
    type_int => Token::TypeInt,

    // Punctuation
    "->" => Token::Arrow,
    "%" => Token::Percent,
    "(" => Token::LeftParen,
    ")" => Token::RightParen,
    "{" => Token::LeftBrace,
    "}" => Token::RightBrace,
    "=" => Token::Equal,
    ";" => Token::Semicolon,
    ":" => Token::Colon,
    "+" => Token::Plus,
    "-" => Token::Minus,
    "*" => Token::Star,
    "/" => Token::Slash,
    "==" => Token::EqualEqual,
    ">" => Token::Greater,
    ">=" => Token::GreaterEqual,
    "<" => Token::Less,
    "<=" => Token::LessEqual,
    "!" => Token::Bang,
    "!=" => Token::BangEqual,
    "," => Token::Comma,
    "." => Token::Dot,
  }
}
